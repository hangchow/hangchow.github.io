---
layout: post
title: MAT之OQL 
tags: mat oql tracing
---

{{ page.title }}
================

<p class="meta">11 June 2012 - Shanghai</p>

OQL语法
----------------------------

[MAT](http://www.eclipse.org/mat/) 有内置的对象查询语言(OQL), OQL用来以类SQL风格的语句查询heap堆栈. 
拿OQL和SQL比较, classes相当于tables, objects相当于rows, fields相当于columns. 因此OQL的基本语法像这样:
	SELECT * FROM [ INSTANCEOF ]	<class_name> [ WHERE <filter-expression>]

### SELECT子句
SELECT子句决定查看对象的内容. 使用星号(*)返回Class Name(点击后浏览outgoing引用), Shallow Heap, Related Heap, 比如:
	SELECT * FROM java.lang.String

### 指定显示内容
或者,可以指定显示内容:
	SELECT toString(s), s.count, s.value, s.@usedHeapSize, s.@retainedHeapSize 
		FROM java.lang.String s

这是另外一个例子,查询对象TcpSocketReceiver内成员变量m_queue(LinkedBlockingQueue)的大小:
	SELECT s.m_queue.count.value 
		FROM com.dianping.cat.message.io.TcpSocketReceiver s 

### 指定显示列名
使用AS给列命名:
	SELECT toString(s) AS Value,
	    s.@usedHeapSize AS "Shallow Size",
	    s.@retainedHeapSize AS "Retained Size"
				FROM java.lang.String s

### 结果去重
使用DISTINCT对结果对象去重:
	SELECT DISTINCT * FROM OBJECTS 0,1,1,2

使用DISTINCT OBJECTS:
	SELECT DISTINCT OBJECTS classof(s) FROM java.lang.String s
函数classof返回类对象. 当然所有的String对象返回相同的类对象. OBJECTS把classof返回的结果行转换成String对象.

FROM子句
----------------------------

### Specify the class
The FROM clause defines the classes on which to operate. Specifiy the class by one of the following means:

#### by class name:
	SELECT * FROM java.lang.String
#### by a regular expression matching the class name:
	SELECT * FROM "java\.lang\..*"
#### by the object address of the class:
	SELECT * FROM 0xe14a100
#### by the object id:
	SELECT * FROM 3022
#### by a sub select:
	SELECT * FROM ( SELECT *
		FROM java.lang.Class c
		WHERE c implements org.eclipse.mat.snapshot.model.IClass )
The statement returns all objects in the heap. The implements check is necessary, as the heap dump can contain java.lang.Class instances caused by proxy classes. The same effect has the following query, which calls a method directly on the ISnapshot object:
	SELECT * FROM ${snapshot}.getClasses()

### Include sub classes
Use the INSTANCEOF keyword to include objects of sub-classes into the query:
	SELECT * FROM INSTANCEOF java.lang.ref.Reference

The resulting table contains, amongst others, WeakReference and SoftReference objects because both classes extend from java.lang.ref.Reference . By the way, the same result has the following query
	SELECT * FROM ${snapshot}.getClassesByName("java.lang.ref.Reference", true)

### Prevent interpretation of the from term as classes
Use the OBJECTS keyword if you do not want to process the term as classes:
	SELECT * FROM OBJECTS java.lang.String
The result is just one object, the java.lang.String class object.


References
----------------------
Eclipse Memory Analyzer Version 1.1.0的help content -> Reference -> OQL Syntax